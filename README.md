## Title

A.C.M.E. (Access Control Management for Enterprises)

## Group members

Carlin Nicola - mat. 239943

Mich Edoardo - mat. 239947

Moletta Davide - mat. 239272

## Category

Protection of data (hybrid)

## Description of the scenario

Our project aims to enforce access control policies in a company, exploiting a per file base encryption.

The project consists of a shared storage (directory) that contains encrypted files which are accessible by the company employees depending on their privileges (rw) on the file.

Whenever a user wants to access a file, a request is sent to a server (a different one in respect to the storage one) for the user authentication via mTLS + company credential. If the user does not have access to that file the request is rejected (the client does not retrieve the decryption key for the file). Otherwise the server checks which privileges the user has on the file. Depending on that, the server decides whether to grant the access requested or not.

If the access is granted the server sends the password to decrypt the file and sends it to the client via the mTLS channel (encrypting it with the device public key). 

## Requirements

The project requires the user to have a “company account” and a device managed (by the company, so with a certificate inside) to access the shared directory.

We will not be in charge of managing company devices, storage and accounts (sharing certificates, renew of certificates, etc...). Without implementing LDAP in the PoC we will use some bogus users as if they where part of the company users list; For certificates we only check their validity.

The files will be encrypted with symmetric encryption and the key will be generated by the server randomly. The key will then be saved on the server in an encrypted way (with the server master key). The server will be the only one in charge of the symmetric keys. Files will be stored in the shared company’s memory and hashes will be used for integrity checking.

The server that manages the access control is our critical point. To reduce the risk, the server will be protected with Shamir Adi secret sharing.

Since the database entries can be decrypted only with the master key of the server we must put special attention in protecting it. To do so, we plan to use Shamir Adi secret sharing because we want the master key (our secret) to be shared among more people. The server will start in a sealed way and it is "unlocked" only if we reach a quorum among key holders.

For example we can split the master key into 5 pieces using SSS and assign one piece to one person. We can then set the quorum to 3 so that at least 3 people are needed to compose the master key. This resolves situations in which one holder can guess the other two pieces (this would be possible if we just split the key into X sequential pieces without SSS).

A "guard" will be implemented in the application side for attribute violation checking.

We will use TLSv1.3 and JAVA sockets to implement secure communications.